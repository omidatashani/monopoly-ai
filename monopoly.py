# -*- coding: utf-8 -*-
"""Monopoly.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DIW2o6svn1PJKQLMooSONhO-INQGVNFA
"""

# importing libraries
import pandas as pd
from copy import deepcopy
import random

class Property():
    def __init__(self, name, space, color, position, price, build_price, rent0, rent1, rent2, rent3, rent4, rent5) -> None:
        self.name = name
        self.space = space
        self.color = color
        self.position = position
        self.price = price
        self.build_price = build_price
        # Creating a list for Rents
        self.rentl = []
        self.rentl.append(rent0)
        self.rentl.append(rent1)
        self.rentl.append(rent2)
        self.rentl.append(rent3)
        self.rentl.append(rent4)
        self.rentl.append(rent5)
        # This one is for safety
        self.rentl.append(rent5)
        self.level = 0
        self.ownable = False
        self.upgradable = True if space in ["Street"] else False
        if space in ["Street", "Railroad", "Utility"]:
            self.ownable = True
            self.owner = None
            self.level = 0
        self.rent = self.rentl[self.level]
        self.max_rent = self.rentl[5]

    def upgrade(self) -> None:
        self.level += 1
        if self.level >= 5:
            self.upgradable = False
        self.rent = self.rentl[self.level]
    
    def __str__(self):
        # Format the string using f-strings and return it
        return f"{self.name} - Price: {self.price}$, Rent: {self.rent}$"

class Player():
    def __init__(self, name, position, money):
        self.name = name
        self.position = position
        self.money = money
        self.properties = []
        self.is_in_jail = False
        self.turns_in_jail = 0
        self.rolled_doubles = False

    def pay_money(self, amount)-> None:
        self.money -= amount

    def get_money(self, amount) -> None:
        self.money += amount

    def roll_dice(self) -> int:
        dice1 = random.randint(1, 6)
        dice2 = random.randint(1, 6)
        total = dice1 + dice2
        if total == 12:
          self.rolled_doubles = True
        print(f"{self.name} rolled {dice1} and {dice2} ({total})")
        return total
    
    def net_worth(self, props) -> int:
        # Calculate current rent
        current_rent = sum([props[i].rent for i in self.properties])
        
        # Calculate next potential rent with all properties
        potential_rent = sum([props[i].rentl[props[i].level+1] for i in self.properties])
        
        # Calculate current property value
        prop_value = sum([props[i].price for i in self.properties])
        
        # Calculate net worth
        return self.money + prop_value + potential_rent
    
    def __str__(self) -> str:

        return f"{self.name}\n" \
            f"Position: {self.position}\n" \
            f"Money: {self.money}$\n" \
            f"Properties: {self.properties}"

# What each action number mean
ACTIONS = {
    0: "does nothing",
    1: "buys prop",
    2: "pays rent",
    3: "upgrades prop",
    4: "goes to jail",
    5: "stays in jail",
    6: "bails out of jail",
    7: "is freed from jail",
    8: "pays tax"
}

class MonopolyGame:
    def __init__(self, board: list=[], players: list=[], current_player: int=0, other_player: int=1, game_over: bool=False):
        # Initializing the game
        self.board = board  # List to represent the game board
        self.players = players  # List to represent the players
        self.current_player = current_player  # Index of the current player in the players list
        self.other_player = other_player
        self.game_over = game_over  # Boolean flag to indicate if the game is over
    
    def initialize_board(self, file_name: str):
        # Initializing the game board from a csv file
        df = pd.read_csv(file_name)

        for row in df.itertuples():
            name = row[1]
            space = row[2]
            color = row[3]
            position = row[4]
            price = row[5]
            build_price = row[6]
            rent = row[7]
            rent1 = row[8]
            rent2 = row[9]
            rent3 = row[10]
            rent4 = row[11]
            rent5 = row[12]
            
            self.board.append(Property(name, space, color, int(position), int(price), int(build_price), int(rent), int(rent1), int(rent2), int(rent3), int(rent4), int(rent5)))

    def initialize_players(self) -> None:
        # Initializing two players with their starting positions, money, and other attributes
        player1 = Player("P1", 0, 1500)
        player2 = Player("P2", 0, 1500)
        self.players = [player1, player2]

    def take_action(self, action: int):
        # Updating the game state based on the action taken by the current player
        new_players = deepcopy(self.players)
        new_board = deepcopy(self.board)
        curr_player = new_players[self.current_player]
        curr_position = curr_player.position
        curr_prop = new_board[curr_position]
        # Do the appropriate changes for the action
        if action == 0:
            pass
        elif action == 1:
            curr_player.pay_money(curr_prop.price)
            curr_player.properties.append(curr_position)
            curr_prop.owner = self.current_player    
        elif action == 2:
            curr_player.pay_money(curr_prop.rent)
            new_players[curr_prop.owner].get_money(curr_prop.rent)
        elif action == 3:
            curr_prop.upgrade()
            curr_player.pay_money(curr_prop.build_price)
        elif action == 4:
            curr_player.position = 10
            curr_player.is_in_jail = True
            curr_player.turns_in_jail += 1
        elif action == 5:
            curr_player.turns_in_jail += 1
        elif action == 6:
            curr_player.pay_money(50)
            curr_player.is_in_jail = False
            curr_player.turns_in_jail = 0
        elif action == 7:
            curr_player.is_in_jail = False
            curr_player.turns_in_jail = 0 
        elif action ==8:
            curr_player.pay_money(curr_prop.rent)      
        return MonopolyGame(new_board, new_players, self.current_player, self.game_over)
    
    def get_possible_actions(self) -> list:
        # Get the possible actions available to the current player
        curr_player = self.players[self.current_player]
        curr_position = curr_player.position
        curr_prop = self.board[curr_position]
        if curr_player.is_in_jail:
            if curr_player.rolled_doubles:
                return [7]
            if curr_player.turns_in_jail >= 3:
                return [6]
            return [5, 6]
        if curr_prop.ownable:
            if curr_prop.owner == self.current_player and curr_prop.upgradable:
                if curr_player.money > curr_prop.build_price:
                    return [3, 0]
                return [0]
            elif curr_prop.owner == None:
                if curr_player.money > curr_prop.price:
                    return [1, 0]
                return [0]
            else:
                return [2]
        if curr_prop.space == "GoToJail":
                return [4]
        if curr_prop.space == "Tax":
                return [8]       
        return [0]
    
    def move_player(self, dice_result:int) -> None:
        # Pass if the player is in jail
        if self.players[self.current_player].is_in_jail:
            return
        curr_player = self.players[self.current_player]
        curr_position = curr_player.position
        # Update the player's position based on the dice roll result
        curr_position = (curr_position + dice_result) % len(self.board)
        curr_player.position = curr_position

    def is_terminal(self) -> bool:
        # Check if the game has reached a terminal state
        curr_player = self.players[self.current_player]
        if curr_player.money <= 0:
            return True
        return False
    
    def evaluate_utility(self) -> int:
        curr_player = self.players[self.current_player]
        curr_net_worth = curr_player.net_worth(self.board)
        # Evaluate the utility of the current game state for the current player
        return curr_net_worth

    def switch_player(self):
        # Switch to the next player's turn
        self.current_player += 1
        self.current_player %= 2

# Probabilities of each dice roll outcome
PROBS = {
    2: 1 / 36,
    3: 2 / 36,
    4: 3 / 36,
    5: 4 / 36,
    6: 5 / 36,
    7: 6 / 36,
    8: 5 / 36,
    9: 4 / 36,
    10: 3 / 36,
    11: 2 / 36,
    12: 1 / 36,
}

def min_node(main_player: int, state: MonopolyGame, depth: int) -> tuple:
    min_eval = float('inf')
    possible_actions = state.get_possible_actions()
    for action in possible_actions:
        # Take the action in a copy of the state
        new_state = state.take_action(action)
        # We should also switch the player
        new_state.switch_player()
        # Recursively call expectiminimax on the new state with depth reduced by 1
        eval, _ = expectiminimax(main_player, new_state, depth - 1, True)
        if eval < min_eval:
            min_eval = eval
            best_action = action
    return min_eval, best_action

def max_node(main_player: int, state: MonopolyGame, depth: int) -> tuple:
    max_eval = float('-inf')
    possible_actions = state.get_possible_actions()
    for action in possible_actions:
        # Take the action in a copy of the state
        new_state = state.take_action(action)
        # We should also switch the player
        new_state.switch_player()
        # Recursively call expectiminimax on the new state with depth reduced by 1
        eval, _ = expectiminimax(main_player,new_state, depth - 1, True)
        if eval > max_eval:
            max_eval = eval
            best_action = action
    return max_eval, best_action

def chance_node(main_player: int, state: MonopolyGame, depth: int) -> tuple:
    expected_utility = 0
    # Account for the all possible dice outcomes
    for dice in range(2, 13):
        state.move_player(dice)
        new_state = state
        # Recursively call expectiminimax on the new state with depth reduced by 1
        eval, _ = expectiminimax(main_player, new_state, depth - 1, False)
        expected_utility += eval * PROBS[dice]
    return expected_utility, None

def expectiminimax(main_player: int, state: MonopolyGame, depth: int=4, chance: bool=False) -> tuple:
    # Expectiminimax algorithm to search for the best action
    if state.is_terminal() or depth == 0:
        return state.evaluate_utility(), None
    # Determining which node we're on
    if chance:
        node = chance_node
    elif state.current_player == main_player:
        node = max_node
    else:
        node = min_node 
    return node(main_player, state, depth)

def play(state: MonopolyGame) -> None:
        num_of_rounds = 0
        # Main game loop to play the game
        while not state.game_over:
            # Get current player from state
            curr_player = state.players[state.current_player]
            print(f"{curr_player.name} is on {curr_player.position} and has {curr_player.money}$,")
            
            if curr_player.is_in_jail:
                print(f"turns in jail {curr_player.turns_in_jail}")
            
            total_dice = curr_player.roll_dice()
            # Moving the player based on the dice outcome
            state.move_player(total_dice)
            curr_position = curr_player.position
            curr_prop = state.board[curr_position]
            print(f"{curr_player.name} lands on {curr_position} which is {curr_prop.name}.", end=" ")

            # Determining the best possible action
            _, best_action = expectiminimax(state.current_player, state)
            
            # Taking the best action
            state = state.take_action(best_action)
            print(f"{curr_player.name} {ACTIONS[best_action]}.")
            print(state.players[state.current_player])
            print(f"Current net worth: {state.evaluate_utility()}")

            if state.is_terminal():
                state.game_over = True
            else:
                state.switch_player()
            num_of_rounds += 1
            print(f"Round: {num_of_rounds}")
            print("====================================================")
        print(f"{state.players[0 if state.current_player else 1].name} Won!")

url = 'https://drive.google.com/file/d/19WxTQDdLzn9IlKnXmxzDSxLBzvjdp6Pa/view?usp=sharing'
url = 'https://drive.google.com/uc?id=' + url.split('/')[-2]

# Driver code to start the Monopoly game
if __name__ == "__main__":
    game = MonopolyGame()
    game.initialize_players()
    game.initialize_board(url)
    play(game)